=begin
=ベース/Window

ここではWindowを中心に扱います


==更新履歴
  Date     Version Author Comment
==14/12/13 2.0.0   トリス 統合A～E B D
==14/12/19 2.0.1   トリス 統合F～I F
==15/09/03 2.0.2   トリス 統合J～U J M Q R T
==17/05/16 2.0.4   トリス 統合V～W V

=end

#==============================================================================
# ■ Window_Base
#==============================================================================
class Window_Base < Window
  #--------------------------------------------------------------------------
  # ● 各種文字色の取得
  #--------------------------------------------------------------------------
  def good_color;         text_color(29);  end;    # 良性結果
  def bad_color;          text_color(18);  end;    # 悪性結果
  def special_color;      text_color(17);  end;    # 特殊結果
  def hp_cost_color;      text_color(10);  end;    # 消費 HP
  def gold_cost_color;    text_color(17);  end;    # 消費 金額  

  #--------------------------------------------------------------------------
  # ○ TP の描画(XP画面サイズのエイリアス再定義)
  #--------------------------------------------------------------------------
  def draw_actor_tp_vga(actor, x, y, width = 124)
    draw_gauge(x, y, width, actor.tp_rate, tp_gauge_color1, tp_gauge_color2)
    change_color(system_color)
    draw_text(x, y, 30, line_height, Vocab::tp_a)
    draw_current_and_max_values(x, y, width, actor.tp, actor.max_tp, tp_color(actor), normal_color)
  end
  #--------------------------------------------------------------------------
  # ○ シンプルなステータスの描画
  #--------------------------------------------------------------------------
  def draw_actor_simple_status(actor, x, y, next_exp = false)
    draw_actor_name(actor, x, y, 152)
    last_font_size = contents.font.size
    contents.font.size = 20
    #
    change_color(system_color)
    draw_text(x + 150, y + contents.font.size * 0 + 5, 22, line_height, Vocab::level_a)
    change_color(normal_color)
    draw_text(x + 159, y + contents.font.size * 0 + 5, 33, line_height, actor.base_level, 2)
    #
    change_color(tp_gauge_color2)
    draw_text(x, y + contents.font.size * 1 + 5, 152, line_height, actor.class.name)
    change_color(system_color)
    draw_text(x + 150, y + contents.font.size * 1 + 5, 22, line_height, Vocab::level_a)
    change_color(normal_color)
    draw_text(x + 159, y + contents.font.size * 1 + 5, 33, line_height, actor.class_level, 2)
    #
    change_color(mp_gauge_color2)
    draw_text(x, y + contents.font.size * 2 + 5, 152, line_height, actor.tribe.name)
    change_color(system_color)
    draw_text(x + 150, y + contents.font.size * 2 + 5, 22, line_height, Vocab::level_a)
    change_color(normal_color)
    draw_text(x + 159, y + contents.font.size * 2 + 5, 33, line_height, actor.tribe_level, 2)
    contents.font.size = last_font_size
    draw_actor_hp(actor, x + 200, y + line_height * 0, 140)
    draw_actor_mp(actor, x + 200, y + line_height * 1, 140)
    draw_actor_tp(actor, x + 200, y + line_height * 2, 140)
    #
    if next_exp
      change_color(normal_color)
      last_font_out_color = contents.font.out_color.clone
      contents.font.out_color = Color.new(0,0,64,192)
      base_next_level  = actor.max_level?(:base)  ? "COMPLETE" : actor.next_level_exp(:base) - actor.base_exp      
      class_next_level = actor.max_level?(:class) ? "COMPLETE" : actor.next_level_exp(:class) - actor.class_exp
      tribe_next_level = actor.max_level?(:tribe) ? "COMPLETE" : actor.next_level_exp(:tribe) - actor.tribe_exp
      text = "NEXT #{base_next_level} / #{class_next_level} / #{tribe_next_level}"
      draw_text(x + 3, y + line_height * 3, 360, contents.font.size, text)    
      contents.font.out_color = last_font_out_color
    else
      draw_actor_icons(actor, x, y + line_height * 3) 
    end
  end
  #--------------------------------------------------------------------------
  # ○ アイテム名の描画
  #     enabled : 有効フラグ。false のとき半透明で描画
  #--------------------------------------------------------------------------
  def draw_item_name(item, x, y, enabled = true, width = 236)
    return unless item
    draw_icon(item.icon_index, x, y, enabled)
    change_color(normal_color, enabled)
    draw_text(x + 24, y, width - 24, line_height, item.name)
  end
  #--------------------------------------------------------------------------
  # ○ 通貨単位つき数値（所持金など）の描画
  #------------------------------------------------------------------------
  # align指定機能を追加
  #--------------------------------------------------------------------------
  def draw_currency_value(value, unit, x, y, width, align = 2)
    case align
    when 2
      cx = text_size(unit).width
      change_color(normal_color)
      draw_text(x, y, width - cx - 2, line_height, value, 2)
      change_color(system_color)
      draw_text(x, y, width, line_height, unit, 2)
    when 1
      uw = text_size(unit).width
      vw = text_size(value.to_s + unit).width + uw / 2
      x = (width - w) / 2
      change_color(normal_color)
      draw_text(x, y, vw - uw, line_height, value)
      change_color(system_color)
      draw_text(x + vw, y, uw, line_height, unit)
    else
      uw = text_size(unit).width
      vw = text_size(value.to_s).width + uw / 2
      change_color(normal_color)
      draw_text(x, y, vw, line_height, value)
      change_color(system_color)
      draw_text(x + vw, y, uw, line_height, unit)
    end
  end
end

#==============================================================================
# ■ Window_Help
#==============================================================================
class Window_Help < Window_Base
  #--------------------------------------------------------------------------
  # ○ リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    rect = Rect.new(4, 0, contents.width - 4, line_height)
    @text.lines{|text| draw_text(rect, text.chomp); rect.y += line_height}
  end
end

#==============================================================================
# ■ Window_Help_Color
#==============================================================================
class Window_Help_Color < Window_Help
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    x = 4
    y = 0
    @text.lines{|text| draw_text_ex(4, y, text); y += line_height}
  end
end

#==============================================================================
# ■ Window_MenuCommand
#==============================================================================
class Window_MenuCommand < Window_Command
  #--------------------------------------------------------------------------
  # ○ 主要コマンドをリストに追加
  #--------------------------------------------------------------------------
  def add_main_commands
    add_command(Vocab::item,   :item,   main_commands_enabled)
    add_command(Vocab::equip,  :equip,  main_commands_enabled)
    add_command(Vocab::skill,  :skill,  main_commands_enabled)
    add_skill_custom_commands
    add_command(Vocab::status, :status, main_commands_enabled)
  end
  #--------------------------------------------------------------------------
  # ● スキル装備コマンドをリストに追加
  #--------------------------------------------------------------------------
  def add_skill_custom_commands
    add_command(Vocab::Ability,  :ability,  main_commands_enabled)
  end
  #--------------------------------------------------------------------------
  # ○ 独自コマンドの追加用
  #--------------------------------------------------------------------------
  def add_original_commands
    add_command("Library", :library)
    add_command("Config", :config)
  end
  #--------------------------------------------------------------------------
  # ○ 並び替えの有効状態を取得
  #--------------------------------------------------------------------------
  def formation_enabled
    $game_party.members.size >= 2 && !$game_system.formation_disabled && $game_player.followers.visible
  end
end

#==============================================================================
# ■ Window_MenuStatus
#==============================================================================
class Window_MenuStatus < Window_Selectable
  #--------------------------------------------------------------------------
  # ○ 決定ボタンが押されたときの処理
  #--------------------------------------------------------------------------
  def process_ok
    if current_item_enabled?
#      Sound.play_ok
      Input.update
      deactivate
      call_ok_handler
    else
      Sound.play_buzzer
    end
    $game_party.menu_actor = $game_party.members[index]
  end
  #--------------------------------------------------------------------------
  # ● 選択項目の有効状態を取得
  #--------------------------------------------------------------------------
  def current_item_enabled?
    return false if pending_index >= 0 && no_change_all_dead?
    return true
  end
  #--------------------------------------------------------------------------
  # ● メンバー入れ替えでの全滅防止
  #--------------------------------------------------------------------------
  def no_change_all_dead?
    return true if $game_party.no_swap_all_dead?(index, pending_index)
    return false
  end
end

#==============================================================================
# ■ Window_MenuActor
#==============================================================================
class Window_MenuActor < Window_MenuStatus
  #--------------------------------------------------------------------------
  # ● 選択項目の有効状態を取得
  #--------------------------------------------------------------------------
  def current_item_enabled?
    return true
  end
end

#==============================================================================
# ■ Window_SkillCommand
#==============================================================================
class Window_SkillCommand < Window_Command
  #--------------------------------------------------------------------------
  # ● 前回の選択位置を復帰
  #--------------------------------------------------------------------------
  def select_last
    stype_id = @actor.get_last_stype
    select(0)
    select_ext(stype_id)
  end
  #--------------------------------------------------------------------------
  # ● 決定やキャンセルなどのハンドリング処理
  #--------------------------------------------------------------------------
  def process_handling
    return unless open? && active
    return process_swap(-1)    if Input.press?(:X)   && Input.repeat?(:UP)
    return process_swap( 1)    if Input.press?(:X)   && Input.repeat?(:DOWN)
    return process_clear_swap  if Input.press?(:X)   && Input.trigger?(:B)
    return process_ok       if ok_enabled?        && Input.trigger?(:C)
    return process_cancel   if cancel_enabled?    && Input.trigger?(:B)
    return process_pagedown if handle?(:pagedown) && Input.trigger?(:R)
    return process_pageup   if handle?(:pageup)   && Input.trigger?(:L)
    return process_sub      if Input.trigger?(:A)
  end
  #--------------------------------------------------------------------------
  # ● サブキー(Aボタン)が押されたときの処理
  #--------------------------------------------------------------------------
  def process_sub
    Sound.play_ok
    Input.update
    @actor.flip_skill_type_disabled(current_ext)
    refresh
  end
  #--------------------------------------------------------------------------
  # ● 並べ替えの処理
  #--------------------------------------------------------------------------
  def process_swap(plus)
    Input.update
    target = index + plus
    return Sound.play_buzzer unless (0..item_max-1).include?(target)
    Sound.play_equip
    @actor.swap_stype_sort(@list[index][:ext], @list[target][:ext])
    refresh
    select(target)
  end
  #--------------------------------------------------------------------------
  # ● 並べ替えリセットの処理
  #--------------------------------------------------------------------------
  def process_clear_swap
    Sound.play_equip
    Input.update
    last_ext = current_ext
    @actor.clear_stype_sort
    refresh
    select_ext(last_ext)
  end
  #--------------------------------------------------------------------------
  # ○ コマンドリストの作成
  #--------------------------------------------------------------------------
  def make_command_list
    return unless @actor
    all_skill_types = @actor.skills.collect{|skill| skill.stype_id}.uniq
    all_skill_types.reject!{|stype_id| NWConst::Ability::ABILITY_SKILL_TYPE.include?(stype_id)}
    enable_skill_types = @actor.added_skill_types
    enable_skill_types.reject!{|stype_id| @actor.skill_type_sealed?(stype_id)}
    
    all_skill_types.select{|stype_id|
      stype_usable?(stype_id)
    }.tap {|stypes|
      break @actor.sorted_stypes(stypes)
    }.each{|stype_id|
      name = $data_system.skill_types[stype_id]
      add_command(name, :skill, enable_skill_types.include?(stype_id), stype_id)
    }
  end
  #--------------------------------------------------------------------------
  # ● 項目の描画
  #--------------------------------------------------------------------------
  def draw_item(index)
    super(index)
    return unless @actor.skill_type_disabled?(@list[index][:ext])
    change_color(bad_color, command_enabled?(index))
    draw_text(item_rect_for_text(index), "封", 2)
  end
  #--------------------------------------------------------------------------
  # ● 選択項目の有効状態を取得
  #--------------------------------------------------------------------------
  def current_item_enabled?
    return true
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    if @skill_window
      @skill_window.stype_unusable = !current_data[:enabled]
      @skill_window.stype_id = current_ext
    end
  end
  #--------------------------------------------------------------------------
  # ● カーソルの移動可能判定
  #--------------------------------------------------------------------------
  def cursor_movable?
    super && !Input.press?(:X)
  end
  #--------------------------------------------------------------------------
  # ● 使用可能なスキルタイプ？（そのタイプのスキルを習得している）
  #--------------------------------------------------------------------------
  def stype_usable?(stype_id)
    @actor.skills.any?{|skill| skill.stype_id == stype_id}
  end
end

#==============================================================================
# ■ Window_SkillStatus
#==============================================================================
class Window_SkillStatus < Window_Base
  #--------------------------------------------------------------------------
  # ○ リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    return unless @actor
    draw_actor_face(@actor, 0, 0)
    draw_actor_simple_status(@actor, 108, 0)
  end
end

#==============================================================================
# ■ Window_SkillList
#==============================================================================
class Window_SkillList < Window_Selectable
  #--------------------------------------------------------------------------
  # ● 公開インスタンス変数
  #--------------------------------------------------------------------------
  attr_accessor :stype_unusable
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  alias :nw_toris_initialize :initialize
  def initialize(x, y, width, height)
    @item_cost_window = Window_ItemCost.new(self)
    nw_toris_initialize(x, y, width, height)
  end
  #--------------------------------------------------------------------------
  # ● フレーム更新
  #--------------------------------------------------------------------------
  def update
    super
    @item_cost_window.z = self.z + 100
    @item_cost_window.update
  end
  #--------------------------------------------------------------------------
  # ● ウィンドウのアクティブ化
  #--------------------------------------------------------------------------
  def activate
    super
    @item_cost_window.refresh
  end
  #--------------------------------------------------------------------------
  # ● ウィンドウの非アクティブ化
  #--------------------------------------------------------------------------
  def deactivate
    super
    @item_cost_window.hide
  end
  #--------------------------------------------------------------------------
  # ● 解放
  #--------------------------------------------------------------------------
  def dispose
    super
    @item_cost_window.dispose
  end
  #--------------------------------------------------------------------------
  # ● 項目の選択
  #--------------------------------------------------------------------------
  def select(index)
    super(index)
    @item_cost_window.refresh
  end
  #--------------------------------------------------------------------------
  # ● 前回の選択位置を復帰
  #--------------------------------------------------------------------------
  def select_last
    select(0)
    select(@data.index(@actor.get_last_skill(@stype_id)) || 0)
  end
  #--------------------------------------------------------------------------
  # ● アイテムリストの作成
  #--------------------------------------------------------------------------
  alias :nw_toris_make_item_list :make_item_list
  def make_item_list
    nw_toris_make_item_list
    @item_cost_window.set_size(@data)
  end
  #--------------------------------------------------------------------------
  # ● 画面に対するカーソル枠の下端
  #--------------------------------------------------------------------------
  def cursor_y_down
    return self.y + standard_padding + item_rect(index).y + line_height - self.oy
  end
  #--------------------------------------------------------------------------
  # ○ スキルをリストに含めるかどうか
  #--------------------------------------------------------------------------
  def include?(item)
    item && item.stypes.include?(@stype_id)
  end  
  #--------------------------------------------------------------------------
  # ● 選択項目の有効状態を取得
  #--------------------------------------------------------------------------
  def current_item_enabled?
    enable?(@data[index]) && !@stype_unusable
  end
  #--------------------------------------------------------------------------
  # ● アイテム名の描画
  #     enabled : 有効フラグ。false のとき半透明で描画
  #--------------------------------------------------------------------------
  def draw_item_name(item, x, y, enabled = true, width = 236)
    return unless item
    draw_icon(item.icon_index, x, y, enabled)
    color = @stype_unusable ? bad_color : normal_color
    change_color(color, enabled)
    draw_text(x + 24, y, width, line_height, item.name)
  end
  #--------------------------------------------------------------------------
  # ○ スキルの使用コストを描画
  #--------------------------------------------------------------------------
  def draw_skill_cost(rect, skill)
    if @actor.skill_mp_cost(skill) > 0 && @actor.skill_tp_cost(skill) > 0
      # MP & SP
      r = Rect.new.set(rect)
      r.x += rect.width
      r.x -= text_size(@actor.skill_tp_cost(skill)).width
      change_color(tp_cost_color, enable?(skill))
      draw_text(r, @actor.skill_tp_cost(skill), 0)
      r.x -= text_size("/").width
      change_color(normal_color, enable?(skill))
      draw_text(r, "/", 0)
      r.x -= text_size(@actor.skill_mp_cost(skill)).width
      change_color(mp_cost_color, enable?(skill))
      draw_text(r, @actor.skill_mp_cost(skill), 0)
    elsif @actor.skill_hp_cost(skill) > 0 && @actor.skill_mp_cost(skill) > 0
      # HP & MP
      r = Rect.new.set(rect)
      r.x += rect.width
      r.x -= text_size(@actor.skill_mp_cost(skill)).width
      change_color(mp_cost_color, enable?(skill))
      draw_text(r, @actor.skill_mp_cost(skill), 0)
      r.x -= text_size("/").width
      change_color(normal_color, enable?(skill))
      draw_text(r, "/", 0)
      r.x -= text_size(@actor.skill_hp_cost(skill)).width
      change_color(hp_cost_color, enable?(skill))
      draw_text(r, @actor.skill_hp_cost(skill), 0)
    elsif @actor.skill_hp_cost(skill) > 0 && @actor.skill_tp_cost(skill) > 0
      # HP & SP
      r = Rect.new.set(rect)
      r.x += rect.width
      r.x -= text_size(@actor.skill_tp_cost(skill)).width
      change_color(tp_cost_color, enable?(skill))
      draw_text(r, @actor.skill_tp_cost(skill), 0)
      r.x -= text_size("/").width
      change_color(normal_color, enable?(skill))
      draw_text(r, "/", 0)
      r.x -= text_size(@actor.skill_hp_cost(skill)).width
      change_color(hp_cost_color, enable?(skill))
      draw_text(r, @actor.skill_hp_cost(skill), 0)
    elsif @actor.skill_tp_cost(skill) > 0
      # SP
      change_color(tp_cost_color, enable?(skill))
      draw_text(rect, @actor.skill_tp_cost(skill), 2)
    elsif @actor.skill_mp_cost(skill) > 0
      # MP
      change_color(mp_cost_color, enable?(skill))
      draw_text(rect, @actor.skill_mp_cost(skill), 2)
    elsif @actor.skill_hp_cost(skill) > 0
      # HP
      change_color(hp_cost_color, enable?(skill))
      draw_text(rect, @actor.skill_hp_cost(skill), 2)
    elsif @actor.skill_gold_cost(skill) > 0
      # ゴールド
      change_color(gold_cost_color, enable?(skill))
      draw_text(rect, @actor.skill_gold_cost(skill), 2)
    end
  end
end
#==============================================================================
# ■ Window_ItemCost
#==============================================================================
class Window_ItemCost < Window_Base
  #--------------------------------------------------------------------------
  # ● オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize(super_window)
    @super_window = super_window
    @max_width = 0
    @max_item  = 0
    super(0, 0, window_width, window_height)
    self.arrows_visible = false
    hide
  end
  #--------------------------------------------------------------------------
  # ● ウィンドウ幅の取得
  #--------------------------------------------------------------------------
  def window_width
    w = [@max_width, 186].max
    plus_col = (@max_item - 1) / 4
    plus_col = 0 if @max_item == 5
    return [w + (w + col_space) * plus_col + standard_padding * 2 + 8,
           Graphics.width].min
  end
  #--------------------------------------------------------------------------
  # ● 横に項目が並ぶときの空白の幅を取得
  #--------------------------------------------------------------------------
  def col_space
    return (@max_item < 9 ? 16 : 0)
  end
  #--------------------------------------------------------------------------
  # ● ウィンドウ高さの取得
  #--------------------------------------------------------------------------
  def window_height
    return fitting_height(4)
  end
  #--------------------------------------------------------------------------
  # ● ウィンドウ内容の幅を計算
  #--------------------------------------------------------------------------
  def contents_width
    Graphics.width
  end
  #--------------------------------------------------------------------------
  # ● ウィンドウ内容の高さを計算
  #--------------------------------------------------------------------------
  def contents_height
    Graphics.height
  end
  #--------------------------------------------------------------------------
  # ● リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    item = @super_window.item
    return hide if !item or item.item_cost.empty?
    contents.clear
    texts = item_text(item)
    i  = 0
    dx = 4
    texts.delete_at(0) if texts.size == 5 and @max_item == 5
    texts.each {|str|
      c = str.slice!(0, 1).to_i
      change_color(normal_color)
      contents.font.color.alpha = (c == 1 ? 255 : translucent_alpha)
      draw_text(dx, line_height * i, contents_width, line_height, str)
      i += 1
      if i >= 4
        i -= 4
        dx += @max_width + col_space
        i += 1 if texts.size < 8
      end
    }
    border = Graphics.height - self.height
    sy = @super_window.cursor_y_down
    self.y = (sy > border ? @super_window.y : Graphics.height - self.height)
    show
  end
  #--------------------------------------------------------------------------
  # ● 表示する文章の配列
  #--------------------------------------------------------------------------
  def item_text(item)
    texts = ["1Items Consumed"]
    item.item_cost.each {|cost|
      cost_item = $data_items[cost[:id]]
      name = cost_item.name
      have = $game_party.item_number(cost_item)
      c = have >= cost[:num] ? 1 : 0
      texts.push( sprintf("%d%s×%d(Owned：%d)", c, name, cost[:num], have) )
    }
    return texts
  end
  #--------------------------------------------------------------------------
  # ● ウインドウサイズを変更
  #--------------------------------------------------------------------------
  def set_size(data)
    @max_width = 0
    @max_item  = 0
    data.each {|item|
      texts = item_text(item)
      texts.each {|str|
        str.slice!(0, 1)
        @max_width = [@max_width, self.contents.text_size(str).width].max
      }
      @max_item = [@max_item, texts.size].max
    }
    self.width  = window_width
    self.height = window_height
    self.x = Graphics.width  - self.width
    self.y = Graphics.height - self.height
  end
end

#==============================================================================
# ■ Window_EquipStatus
#==============================================================================
class Window_EquipStatus < Window_Base
  #--------------------------------------------------------------------------
  # ○ 項目の描画
  #--------------------------------------------------------------------------
  def draw_item(x, y, param_id)
    draw_param_name(x + 4, y, param_id)
    draw_current_param(x + 74, y, param_id) if @actor
    draw_right_arrow(x + 116, y)
    draw_new_param(x + 140, y, param_id) if @temp_actor
  end
  #--------------------------------------------------------------------------
  # ○ 現在の能力値を描画
  #--------------------------------------------------------------------------
  def draw_current_param(x, y, param_id)
    change_color(normal_color)
    draw_text(x, y, 42, line_height, @actor.param(param_id), 2)
  end
  #--------------------------------------------------------------------------
  # ○ 装備変更後の能力値を描画
  #--------------------------------------------------------------------------
  def draw_new_param(x, y, param_id)
    new_value = @temp_actor.param(param_id)
    change_color(param_change_color(new_value - @actor.param(param_id)))
    draw_text(x, y, 42, line_height, new_value, 2)
  end  
end

#==============================================================================
# ■ Window_Message
#==============================================================================
class Window_Message < Window_Base
  #--------------------------------------------------------------------------
  # ○ ウェイト
  #--------------------------------------------------------------------------
  def wait(duration)
    return if Input.press?(:X)
    duration.times { Fiber.yield }
  end
  #--------------------------------------------------------------------------
  # ○ 一文字出力後のウェイト
  #--------------------------------------------------------------------------
  def wait_for_one_character
    return if Input.press?(:X)
    update_show_fast
    Fiber.yield unless @show_fast || @line_show_fast
  end    
  #--------------------------------------------------------------------------
  # ○ 入力待ち処理
  #--------------------------------------------------------------------------
  def input_pause
    return if Input.press?(:X)
    self.pause = true
    wait(10)
    Fiber.yield until Input.trigger?(:B) || Input.trigger?(:C) || Input.trigger?(:X)
    Input.update
    self.pause = false
  end
  #--------------------------------------------------------------------------
  # ○ 制御文字の処理
  #     code : 制御文字の本体部分（「\C[1]」なら「C」）
  #     text : 描画処理中の文字列バッファ（必要なら破壊的に変更）
  #     pos  : 描画位置 {:x, :y, :new_x, :height}
  #--------------------------------------------------------------------------
  def process_escape_character(code, text, pos)
    case code.upcase
    when '$'
      @gold_window.open
    when '.'
      wait(15)
    when '|'
      wait(60)
    when '!'
      input_pause
    when '>'
      @line_show_fast = true
    when '<'
      @line_show_fast = false
    when '^'
      @pause_skip = true
    when 'D'
      screen = $game_party.in_battle ? $game_troop.screen : $game_party.in_novel ? $game_novel.screen : $game_map.screen
      screen.start_shake(5, 5, 10)
      Sound.play_actor_damage      
    else
      super
    end
  end  
  #--------------------------------------------------------------------------
  # 〇 これから表示する行が、表示領域から横にはみ出るかの判定とその際の処理
  #--------------------------------------------------------------------------
  def setup_reduce_over_line(text, pos)
    @reduce_flag = false
    if @reduce_bitmap
      @reduce_bitmap.dispose
      @reduce_bitmap = nil
    end
    return if text.empty?
    return if text.match('(<.*>)*[A-Za-z]+')
    line_text = text.split(/\n|\f/)[0]
    return unless line_text
    line_text.gsub!(/\eC\[(\d+)\]/i) { "" }
    line_text.gsub!(/\e\$/i) { "" }
    line_text.gsub!(/\e\./i) { "" }
    line_text.gsub!(/\e\|/i) { "" }
    line_text.gsub!(/\e!/i) { "" }
    line_text.gsub!(/\e>/i) { "" }
    line_text.gsub!(/\e</i) { "" }
    line_text.gsub!(/\e\^/i) { "" }
    line_text.gsub!(/\eD/i) { "" }
    line_text_width = text_size(line_text).width
    total_width = pos[:new_x] + line_text_width
    over_flag = total_width > self.contents.width
    return unless over_flag
    print "縮小:"
    p line_text
    @reduce_flag = true
    @reduce_bitmap = Bitmap.new(line_text_width, self.contents.height)
  end
  #--------------------------------------------------------------------------
  # ● 改ページ処理
  #--------------------------------------------------------------------------
  def new_page(text, pos)
    contents.clear
    draw_face($game_message.face_name, $game_message.face_index, 0, 0)
    reset_font_settings
    pos[:x] = new_line_x
    pos[:y] = 0
    pos[:new_x] = new_line_x
    pos[:height] = calc_line_height(text)
    clear_flags
    setup_reduce_over_line(text, pos)
  end
  #--------------------------------------------------------------------------
  # ● 改行文字の処理
  #--------------------------------------------------------------------------
  def process_new_line(text, pos)
    @line_show_fast = false
    super
    if need_new_page?(text, pos)
      input_pause
      new_page(text, pos)
    end
    setup_reduce_over_line(text, pos)
  end
  #--------------------------------------------------------------------------
  # ● 縮小描画：縮小描画ビットマップの描画前準備
  #--------------------------------------------------------------------------
  def prepare_reduce_draw
    @reduce_bitmap.font = self.contents.font.clone
  end
  #--------------------------------------------------------------------------
  # ● 縮小描画：テキストの描画
  #--------------------------------------------------------------------------
  def reduce_draw_text(*args)
    @reduce_bitmap.draw_text(*args)
  end
  #--------------------------------------------------------------------------
  # ● 縮小描画：アイコンの描画
  #--------------------------------------------------------------------------
  def reduce_draw_icon(icon_index, x, y, enabled = true)
    bitmap = Cache.system("Iconset")
    rect = Rect.new(icon_index % 16 * 24, icon_index / 16 * 24, 24, 24)
    @reduce_bitmap.blt(x, y, bitmap, rect, enabled ? 255 : translucent_alpha)
  end
  #--------------------------------------------------------------------------
  # ● 縮小描画：縮小描画コンテンツの反映
  #--------------------------------------------------------------------------
  def reflect_reduce_contents(pos)
    draw_area_width = self.contents.width - pos[:new_x]
    line_rect = Rect.new(pos[:new_x], pos[:y], draw_area_width, line_height)
    self.contents.clear_rect(line_rect)
    dest_rect = Rect.new(pos[:new_x], 0, draw_area_width, self.contents.height)
    self.contents.stretch_blt(dest_rect, @reduce_bitmap, @reduce_bitmap.rect)
  end
  #--------------------------------------------------------------------------
  # ● 通常文字の処理
  #--------------------------------------------------------------------------
  def process_normal_character(c, pos)
    text_width = text_size(c).width
    args = [pos[:x], pos[:y], text_width * 2, pos[:height], c]
    if @reduce_flag
      args[0] -= pos[:new_x]
      prepare_reduce_draw
      reduce_draw_text(*args)
      reflect_reduce_contents(pos)
    else
      draw_text(*args)
    end
    pos[:x] += text_width
    wait_for_one_character
  end
  #--------------------------------------------------------------------------
  # ● 制御文字によるアイコン描画の処理
  #--------------------------------------------------------------------------
  def process_draw_icon(icon_index, pos)
    args = [icon_index, pos[:x], pos[:y]]
    if @reduce_flag
      args[0] -= pos[:new_x]
      prepare_reduce_draw
      reduce_draw_icon(*args)
      reflect_reduce_contents(pos)
    else
      draw_icon(*args)
    end
    pos[:x] += 24
    wait_for_one_character
  end
end

#==============================================================================
# ■ Window_BattleLog
#==============================================================================
class Window_BattleLog < Window_Selectable
  #--------------------------------------------------------------------------
  # ○ オブジェクト初期化
  #--------------------------------------------------------------------------
  def initialize
    super(0, Graphics.height - window_height, window_width, window_height)
    self.z = 200
    @lines = []
    @num_wait = 0
    refresh
  end
  #--------------------------------------------------------------------------
  # ● ウィンドウを開く
  #--------------------------------------------------------------------------
  def open
    self.openness = 255
    self
  end
  #--------------------------------------------------------------------------
  # ● ウィンドウを閉じる
  #--------------------------------------------------------------------------
  def close
    self.openness = 0
    self
  end
  #--------------------------------------------------------------------------
  # ○ 解放
  #--------------------------------------------------------------------------
  def dispose
    super
  end
  #--------------------------------------------------------------------------
  # ○ リフレッシュ
  #--------------------------------------------------------------------------
  def refresh
    contents.clear
    @lines.size.times {|i| draw_line(i) }
  end  
  #--------------------------------------------------------------------------
  # ○ クリア
  #--------------------------------------------------------------------------
  def clear
    @num_wait = 0
    @lines.clear
    refresh
  end
  #--------------------------------------------------------------------------
  # ○ 文章の追加
  #--------------------------------------------------------------------------
  def add_text(text)
    @lines.shift if max_line_number <= line_number
    @lines.push(text)
    refresh
  end
  #--------------------------------------------------------------------------
  # ○ 最大行数の取得
  #--------------------------------------------------------------------------
  def max_line_number
    return 4
  end
  #--------------------------------------------------------------------------
  # ○ 被ダメージセリフ用メソッドの設定
  #--------------------------------------------------------------------------
  def method_process_down_word=(method)
    @method_process_down_word = method
  end
  #--------------------------------------------------------------------------
  # ○ 被ダメージセリフ用処理
  #--------------------------------------------------------------------------
  def process_down_word(target, item)
    @method_process_down_word.call(target, item)
  end
  #--------------------------------------------------------------------------
  # ● 追加制御文字の置換
  #--------------------------------------------------------------------------
  def replace_ext_character(original_text, subject, targets)
    text = original_text.dup
    text.gsub!(/\\u/i) { subject.name }
    text.gsub!(/\\e/i) { targets.first.name }
    return text
  end
  #--------------------------------------------------------------------------
  # ○ スキル／アイテム使用の表示
  #--------------------------------------------------------------------------
  def display_use_item(subject, targets, item)    
    if item.is_skill?
      return if item.message1.empty? && item.message2.empty?
      
      text1 = item.message1 =~ /\\(u|e)/i ? replace_ext_character(item.message1, subject, targets) : (subject.name + item.message1)
      add_text(text1)
      unless item.message2.empty?
        wait
        text2 = item.message2 =~ /\\(u|e)/i ? replace_ext_character(item.message2, subject, targets) : (item.message2)
        add_text(text2)
      end      
    else
      form = item.throw? ? Vocab::ThrowItem : Vocab::UseItem
      add_text(sprintf(form, subject.name, item.name))
    end
  end
  #--------------------------------------------------------------------------
  # ○ 行動結果の表示
  #--------------------------------------------------------------------------
  def display_action_results(target, item, user = nil)
    return unless target.result.used
    last_line_number = line_number
    display_critical(target, item)
    display_damage(target, item)
    display_stealed(target)
    display_stand(target)
    display_restoration(target, user)
    display_over_drive(target)
    display_invalidate_wall(target)
    display_defense_wall(target)
    display_binding_start(target)        
    display_bind_resist(target)
    process_down_word(target, item)
    display_predation(target)
    display_affected_status(target, item)
    display_failure(target, item)
    wait if line_number > last_line_number
    back_to(last_line_number)
  end
  #--------------------------------------------------------------------------
  # ● ダメージの表示 Window_BattleLog 290
  #--------------------------------------------------------------------------
  alias :nw_toris_display_damage :display_damage
  def display_damage(target, item)
    return if target.result.invalidate_wall
    nw_toris_display_damage(target, item)
  end
  #--------------------------------------------------------------------------
  # ○ HP ダメージ表示
  #--------------------------------------------------------------------------
  def display_hp_damage(target, item)
    return if target.result.hp_damage == 0 && item.nil?
    return if target.result.hp_damage == 0 && item && !item.damage.to_hp?
    if target.result.hp_damage > 0 && target.result.hp_drain == 0
      target.perform_damage_effect
    end
    Sound.play_recovery if target.result.hp_damage < 0
    add_text(target.result.hp_damage_text)
    wait
  end    
  #--------------------------------------------------------------------------
  # ● 反射の表示
  #--------------------------------------------------------------------------
  def display_reflection(target, item)
    Sound.play_reflection
    if item.physical?　
      add_text(sprintf(Vocab::PhysicalReflection, target.name))
    else
      add_text(sprintf(Vocab::MagicReflection, target.name))
    end
    wait
    back_one
  end
  #--------------------------------------------------------------------------
  # ● スキル使用失敗
  #--------------------------------------------------------------------------
  def display_unusable(subject, item)
    return unless item.is_skill?
    add_text(subject.result.unusable_text)
    wait_and_clear
  end
  #--------------------------------------------------------------------------
  # ● 捕食
  #--------------------------------------------------------------------------
  def display_predation(subject)
    return unless subject.result.predation
    add_text(sprintf(Vocab::Predation, subject.name))
    wait
  end
  #--------------------------------------------------------------------------
  # ● 永久拘束失敗
  #--------------------------------------------------------------------------
  def display_eternal_bind_resist(bind_user)
    add_text(sprintf(Vocab::EternalBindResist, bind_user.name))
    wait_and_clear
  end
  #--------------------------------------------------------------------------
  # ● スキル対象不在の表示
  #--------------------------------------------------------------------------
  def display_target_empty(subject)
    add_text("#{subject.name}は様子を見ている……")
    wait_and_clear
  end
  #--------------------------------------------------------------------------
  # ● 自己付与
  #--------------------------------------------------------------------------
  def display_user_self_enchant(user, state_id)
    state = $data_states[state_id]
    unless state.message1.empty?
      add_text(user.name + state.message1)
      wait
      wait
      back_one
    end
  end
  #--------------------------------------------------------------------------
  # ● ダメージ還元
  #--------------------------------------------------------------------------
  def display_restoration(subject, user)
    return unless subject.result.restoration?
    add_text(subject.result.restoration_text(user))
    wait
  end
  #--------------------------------------------------------------------------
  # ● スティール実行結果の表示
  #--------------------------------------------------------------------------
  def display_stealed(target)
    return unless target.result.stealed
    if target.result.stealed_item_empty
      add_text(sprintf(Vocab::StealedItemEmpty, target.name))
    elsif target.result.stealed_item_id == 0
      add_text(sprintf(Vocab::StealFailure, target.name))
    else
      case target.result.stealed_item_kind
      when 1; item_format = "\\T[%i]"
      when 2; item_format = "\\W[%i]"
      when 3; item_format = "\\A[%i]"
      end
      # ひきも記メッセージ制御文字拡張機能を使用
      add_text(sprintf(Vocab::Stealed, sprintf(item_format, target.result.stealed_item_id), target.name))
    end
    wait    
  end
  #--------------------------------------------------------------------------
  # ● 踏みとどまりの表示
  #--------------------------------------------------------------------------
  def display_stand(target)
    return unless target.result.auto_stand
    add_text(sprintf(Vocab::Stand, target.name))
    wait
  end
  #--------------------------------------------------------------------------
  # ● 時間停止の表示
  #--------------------------------------------------------------------------
  def display_over_drive(target)
    return unless target.result.over_drive && target.result.success
    add_text(sprintf(Vocab::OverDriveSuccess, target.name))
    wait 
  end  
  #--------------------------------------------------------------------------
  # ● 無効化障壁の表示
  #--------------------------------------------------------------------------
  def display_invalidate_wall(target)
    return unless target.result.invalidate_wall
    add_text(sprintf(Vocab::Invalidate, target.name))
    wait
  end  
  #--------------------------------------------------------------------------
  # ● 防御壁展開の表示
  #--------------------------------------------------------------------------
  def display_defense_wall(target)
    return unless target.result.defense_wall
    add_text(sprintf(Vocab::DefenseWall, target.name))
    wait 
  end  
  #--------------------------------------------------------------------------
  # ● 拘束開始の表示
  #--------------------------------------------------------------------------
  def display_binding_start(target)
    return unless 0 <= target.result.binding_start
    index = target.result.binding_start
    add_text(sprintf(Vocab::BindingStart[index], target.name))
    wait
  end
  #--------------------------------------------------------------------------
  # ● もがくの表示
  #--------------------------------------------------------------------------
  def display_bind_resist(target)
    return unless target.result.bind_resist
    if BattleManager.bind?
      add_text(sprintf(Vocab::BindResistFailure, target.name))    
    else
      add_text(sprintf(Vocab::BindResistSuccess, target.name))    
    end
    wait
  end
  #--------------------------------------------------------------------------
  # ● 反撃の表示
  #--------------------------------------------------------------------------
  def display_counter(target, item)
    Sound.play_evasion
    add_text(sprintf(Vocab::CounterAttack, target.name))
    wait
  end
  #--------------------------------------------------------------------------
  # ● 自爆スキルの表示
  #--------------------------------------------------------------------------
  def display_pay_life(user)
    add_text(sprintf(Vocab::PayLife, user.name))
    user.perform_collapse_effect
    wait
  end  
  #--------------------------------------------------------------------------
  # ● 自爆スキル未遂の表示
  #--------------------------------------------------------------------------
  def display_pay_life_failure(user)
    add_text(sprintf(Vocab::PayLifeFailure, user.name))
    wait
  end    
  #--------------------------------------------------------------------------
  # ● スロット文章の表示
  #--------------------------------------------------------------------------
  def display_slot
    add_text(NWConst::Slot::PLAY_DESC)
  end  
  #--------------------------------------------------------------------------
  # ○ 失敗の表示
  #--------------------------------------------------------------------------
  def display_failure(target, item)
    if target.result.over_drive && !target.result.success
      add_text(Vocab::OverDriveFailure)
      wait
    elsif target.result.hit? && !target.result.success
      add_text(sprintf(Vocab::ActionFailure, target.name))
      wait
    end
  end
  #--------------------------------------------------------------------------
  # ○ ステート付加の表示
  #--------------------------------------------------------------------------
  def display_added_states(target)
    target.result.added_state_objects.each do |state|
      state_msg = target.actor? ? state.message1 : state.message2
      state_msg = Vocab::PleasureFinished if target.result.pleasure && (state.id == target.death_state_id)
      target.perform_collapse_effect if state.death?
      next if state_msg.empty?
      replace_text(target.name + state_msg)
      wait
      wait_for_effect
    end
  end
  #--------------------------------------------------------------------------
  # ● 行の描画
  #--------------------------------------------------------------------------
  def draw_line(line_number)
    rect = item_rect_for_text(line_number)
    contents.clear_rect(rect)
    text_width = text_size(@lines[line_number]).width
    if text_width <= (self.width - standard_padding * 2) - rect.x
      draw_text_ex(rect.x, rect.y, @lines[line_number])
    else
      text_bitmap = Bitmap.new(text_width, line_height)
      text = Marshal.load(Marshal.dump(@lines[line_number]))
      cx = 0
      until text.empty?
        c  = text.slice!(0, 1)
        cw = text_size(c).width
        text_bitmap.draw_text(cx, 0, cw * 2, line_height, c)
        cx += cw
      end
      dest_rect = item_rect(line_number)
      self.contents.stretch_blt(dest_rect, text_bitmap, text_bitmap.rect)
      text_bitmap.dispose
    end
  end
end

#==============================================================================
# ■ Window_PartyCommand
#==============================================================================
class Window_PartyCommand < Window_Command
  #--------------------------------------------------------------------------
  # ○ 桁数の取得
  #--------------------------------------------------------------------------
  def col_max
    return 2
  end
  #--------------------------------------------------------------------------
  # ○ 横に項目が並ぶときの空白の幅を取得
  #--------------------------------------------------------------------------
  def spacing
    return 4
  end
  #--------------------------------------------------------------------------
  # ○ ウィンドウ幅の取得
  #--------------------------------------------------------------------------
  def window_width
    return 200
  end
  #--------------------------------------------------------------------------
  # ○ コマンドリストの作成
  #--------------------------------------------------------------------------
  def make_command_list
    add_command(Vocab::fight,       :fight)
    add_command(Vocab::shift_change,:shift_change, can_shift_change?)
    add_command(Vocab::all_attack,  :all_attack)
    add_command(Vocab::escape,      :escape, BattleManager.can_escape?)
    add_command(Vocab::giveup,      :giveup, $game_party.all_members.any?{|member| member.luca?} && $game_actors[NWConst::Actor::LUCA].exist?)
    add_command(Vocab::library,     :library)
    add_command(Vocab::config,      :config)
  end
  #--------------------------------------------------------------------------
  # ○ 入れ替えコマンドの可否
  #--------------------------------------------------------------------------
  def can_shift_change?
    return false if $game_party.bench_members.empty?
    return false if $game_switches[NWConst::Sw::FORBID_BATTLE_SHIFT_CHANGE]
    return true
  end
end

#==============================================================================
# ■ Window_ActorCommand
#==============================================================================
class Window_ActorCommand < Window_Command
  #--------------------------------------------------------------------------
  # ● 桁数の取得【オーバーライド】
  #--------------------------------------------------------------------------
  def col_max
    return 2
  end
  #--------------------------------------------------------------------------
  # ● 横に項目が並ぶときの空白の幅を取得【オーバーライド】
  #--------------------------------------------------------------------------
  def spacing
    return 4
  end
  #--------------------------------------------------------------------------
  # ● ハンドラの呼び出し
  #--------------------------------------------------------------------------
  def call_handler(symbol)
    @actor.set_last_command(symbol)    if symbol != :cancel
    @actor.set_last_stype(current_ext) if symbol == :skill
    @handler[symbol].call if handle?(symbol)
  end
  #--------------------------------------------------------------------------
  # ● 前回の選択位置を復帰
  #--------------------------------------------------------------------------
  def select_last
    symbol = @actor.get_last_command
    select(0)
    if symbol == :skill
      ext = @actor.get_last_stype
      select_ext(ext)
    else
      select_symbol(symbol)
    end
  end
  #--------------------------------------------------------------------------
  # ○ コマンドリストの作成
  #--------------------------------------------------------------------------
  def make_command_list
    return unless @actor
    add_attack_command
    if @actor.state?(NWConst::State::TBIND) || @actor.state?(NWConst::State::ETBIND)
      add_resist_bind_command
      add_mercy_command
    else
      add_skill_commands
      add_guard_command
      add_mercy_command
      add_item_command
    end
  end
  #--------------------------------------------------------------------------
  # ○ ウィンドウ幅の取得
  #--------------------------------------------------------------------------
  def window_width
    return 200
  end
  #--------------------------------------------------------------------------
  # ● 「もがく」をリストに追加
  #--------------------------------------------------------------------------
  def add_resist_bind_command
    add_command($data_skills[NWConst::Skill::BIND_RESIST].name, :bind_resist)
  end
  #--------------------------------------------------------------------------
  # ● 「なすがまま」をリストに追加
  #--------------------------------------------------------------------------
  def add_mercy_command
    add_command($data_skills[NWConst::Skill::MERCY].name, :mercy)
  end
  #--------------------------------------------------------------------------
  # ○ スキルコマンドをリストに追加
  #--------------------------------------------------------------------------
  def add_skill_commands
    @actor.added_skill_types.sort.select{|stype_id|
      stype_usable?(stype_id)
    }.tap {|stypes|
      break @actor.sorted_stypes(stypes)
    }.each{|stype_id|
      name = $data_system.skill_types[stype_id]
      add_command(name, :skill, true, stype_id)
    }
  end
  #--------------------------------------------------------------------------
  # ● 使用可能なスキルタイプ？（そのタイプのスキルを習得しており非表示でない）
  #--------------------------------------------------------------------------
  def stype_usable?(stype_id)
    @actor.skills.any?{|skill| skill.stype_id == stype_id} &&
    !($game_system.conf[:bt_stype] && @actor.skill_type_disabled?(stype_id))
  end
end

#==============================================================================
# ■ Window_BattleStatus
#==============================================================================
class Window_BattleStatus < Window_Selectable
  #--------------------------------------------------------------------------
  # ● アクター名の描画
  #--------------------------------------------------------------------------
  def draw_actor_name_ex(actor, x, y, enabled)
    change_color(hp_color(actor), enabled)
    draw_text(x, y, 100, line_height, actor.name)
  end
  #--------------------------------------------------------------------------
  # ○ 基本エリアの描画
  #--------------------------------------------------------------------------
  def draw_basic_area(rect, actor)
    draw_actor_name_ex(actor, rect.x + 0, rect.y, !(BattleManager.shift_change? && BattleManager.bind? && actor.luca?))
    draw_actor_icons(actor, rect.x + 104, rect.y, rect.width - 104)
  end
  #--------------------------------------------------------------------------
  # ● 現在選択中のメンバー位置を取得
  #--------------------------------------------------------------------------
  def member_index
    return self.index
  end
  #--------------------------------------------------------------------------
  # ● 選択項目の有効状態を取得
  #--------------------------------------------------------------------------
  def current_item_enabled?
    !(BattleManager.shift_change? && BattleManager.bind? && $game_party.all_members[member_index].luca?)
  end
  #--------------------------------------------------------------------------
  # ○ ウィンドウ幅の取得
  #--------------------------------------------------------------------------
  def window_width
    Graphics.width - 200
  end
  #--------------------------------------------------------------------------
  # ○ ゲージエリアの幅を取得
  #--------------------------------------------------------------------------
  def gauge_area_width
    return 220
  end
  #--------------------------------------------------------------------------
  # ○ ゲージエリアの描画（TP あり）
  #--------------------------------------------------------------------------
  def draw_gauge_area_with_tp(rect, actor)
    draw_actor_hp(actor, rect.x + 0, rect.y, 70)
    draw_actor_mp(actor, rect.x + 80, rect.y, 70)
    draw_actor_tp(actor, rect.x + 160, rect.y, 50)
  end
  #--------------------------------------------------------------------------
  # ○ ゲージエリアの描画（TP なし）
  #--------------------------------------------------------------------------
  def draw_gauge_area_without_tp(rect, actor)
    draw_actor_hp(actor, rect.x + 0, rect.y, 130)
    draw_actor_mp(actor, rect.x + 140,  rect.y, 70)
  end
end

#==============================================================================
# ■ Window_BattleActor
#==============================================================================
class Window_BattleActor < Window_BattleStatus
  #--------------------------------------------------------------------------
  # ● 選択項目の有効状態を取得 【オーバーライド】
  #--------------------------------------------------------------------------
  def current_item_enabled?
    return enable?($game_party.battle_members[index])
  end
  #--------------------------------------------------------------------------
  # ● ターゲットを許可状態で表示するかどうか
  #--------------------------------------------------------------------------
  def enable?(target)
    return if BattleManager.actor == nil
    sex = target.sex
    ext = BattleManager.actor.input.item.ext_scope
    return true if ext == NWSex::ALL
    return (sex & ext) != 0
  end
  #--------------------------------------------------------------------------
  # ● 名前の描画 【オーバーライド】
  #--------------------------------------------------------------------------
  def draw_actor_name(actor, x, y, width = 144)
    change_color(hp_color(actor), enable?(actor))
    draw_text(x, y, width, line_height, actor.name)
  end
end

#==============================================================================
# ■ Window_BattleEnemy
#==============================================================================
class Window_BattleEnemy < Window_Selectable
  #--------------------------------------------------------------------------
  # ○ オブジェクト初期化
  #     info_viewport : 情報表示用ビューポート
  #--------------------------------------------------------------------------
  def initialize(info_viewport)
    super(0, info_viewport.rect.y, window_width, fitting_height(4))
    refresh
    self.visible = false
    @info_viewport = info_viewport
    @friend_draw = false
  end
  #--------------------------------------------------------------------------
  # ● 選択項目の有効状態を取得【オーバーライド】
  #--------------------------------------------------------------------------
  def current_item_enabled?
    return enable?($game_troop.alive_members[index])
  end  
  #--------------------------------------------------------------------------
  # ● ターゲットを許可状態で表示するかどうか
  #--------------------------------------------------------------------------
  # Window_BattleActorとは基底クラスが違います
  def enable?(target)
    return if BattleManager.actor == nil
    sex = target.sex
    ext = BattleManager.actor.input.item.ext_scope
    return true if ext == NWSex::ALL
    return (sex & ext) != 0
  end
  #--------------------------------------------------------------------------
  # ● 友好度表示の設定
  #--------------------------------------------------------------------------  
  def friend_draw=(flag)
    @friend_draw = flag
  end
  #--------------------------------------------------------------------------
  # ○ 項目の描画
  #--------------------------------------------------------------------------
  def draw_item(index)
    e = $game_troop.alive_members[index]
    name = e.name.clone
    name += "(Affinity:#{e.enemy.ex_dungeon_enemy? ? "None" : e.friend})" if @friend_draw
    change_color(normal_color, enable?(e))
    draw_text(item_rect_for_text(index), name)
  end 
end    

#==============================================================================
# ■ Window_BattleItem
#==============================================================================
class Window_BattleItem < Window_ItemList
  #--------------------------------------------------------------------------
  # ● アクターの設定
  #--------------------------------------------------------------------------
  def actor=(actor)
    return if @actor == actor
    @actor = actor
    refresh
    self.oy = 0
  end
  #--------------------------------------------------------------------------
  # ○ アイテムをリストに含めるかどうか
  #--------------------------------------------------------------------------
  def include?(item)
    item.is_a?(RPG::Item) && item.battle_ok?
  end
  #--------------------------------------------------------------------------
  # ○ スキルを許可状態で表示するかどうか
  #--------------------------------------------------------------------------
  def enable?(item)
    @actor && @actor.usable?(item)
  end
end

#==============================================================================
# ■ Window_DebugRight
#==============================================================================
class Window_DebugRight < Window_Selectable
  #--------------------------------------------------------------------------
  # ● 選択項目の再描画
  #--------------------------------------------------------------------------
  def redraw_current_item
    refresh
  end
end


  
